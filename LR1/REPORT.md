# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Фадеев Д.В.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |              |



## Введение
Список, или упорядоченная последовательность элементов - одна из широко используемых структур в программировании. Поскольку список можно рассматривать как вырожденный случай дерева, термы языка Пролог позволяют представлять и обрабатывать в пролог-программах списки из произвольного числа разных элементов (атомов, чисел, термов).

Структура списка определяется рекурсивно: список является либо пустым (без элементов), и обозначается [], либо состоит из двух компонент: первого элемента, называемого головой списка (Head), и остатка-хвоста (Rest), являющегося списком. Список-хвост представляет собой исходный список без первого его элемента, т.е. это всегда список, возможно, пустой. Пустой список же не имеет ни головы, ни хвоста.

Список в языке Prolog представляется в виде двоичного дерева, в листьях которого находится либо эл-т, либо пустой список. Элементами списка являются произвольные термы. То есть это рекурсивная структура, которая либо пуста, либо состоит из головы и хвоста, где хвост тоже список.
```
       •
      / \
    [a]  •
        / \
      [b]  •
          / \
        [c] [ ]
```


## Задание 1.0: Реализация стандартных предикатов обработки списков
Были реализованы следующие стандартные предикаты:
1) Предикат длины списка
```prolog
% Формат ввода: (список, длина)
mlength([], 0) . 
mlength([_|T], N) :- mlength(T, N1), N is N1 + 1.
```
Пример работы:
```
?- mlength([1,2,3], X).
X = 3.

```
2) Предикат принадлежности элемента списку
```prolog
% Формат ввода: (элемент, список)
mmember(X,[X|L]).
mmember(X,[L|T]) :- mmember(X,T).
```
Пример работы:
```
?- mmember(6,[4, 7, 6, 5]).
true 
```
3) Предикат конкатенации списков
```prolog
% Формат ввода: (список1, список2, список1+2)
mappend([],L,L).
mappend([H|T], L, [H|R]) :- mappend(T,L,R).
```
Пример работы:
```
?- mappend([3,4,1], [8, 5,6], X).
X = [3, 4, 1, 8, 5, 6].
```
4) Предикат удаления элементов из списка
```prolog
% Формат ввода: (элемент, список, список без элемента)
mremove(E,[E|S],S).
mremove(E,[E1|S],[E1|X]) :- mremove(E,S,X).
```
Пример работы:
```
?- mremove(1, [1,2,3], X).
X = [2, 3] ;
false.
```
5) Предикат перестановки элементов списка
```prolog
% Формат ввода: (список, перестановка)
mpermute([],[]).
mpermute(S,[L|Y]) :-
    mremove(L,S,X),
    mpermute(X,Y).
```
Пример работы:
```
?- mpermute([1,2,3], X).
X = [1, 2, 3] ;
X = [1, 3, 2] ;
X = [2, 1, 3] ;
X = [2, 3, 1] ;
X = [3, 1, 2] ;
X = [3, 2, 1] ;
false.
```
6) Предикат подсписка списка
```prolog
% Формат ввода: (подсписок, список)
msublist(X,Y) :-
    mappend(S,L,Y),
    mappend(X,S,L).
```
Пример работы:
```
?- msublist(X, [1,2,3,4]).
X = [] ;
X = [1] ;
X = [1, 2] ;
X = [1, 2, 3] ;
X = [1, 2, 3, 4] ;
X = [] ;
X = [2] ;
X = [2, 3] ;
X = [2, 3, 4] ;
X = [] ;
X = [3] ;
X = [3, 4] ;
X = [] ;
X = [4] ;
X = [] ;
false.
```
## Задание 1.1: Предикат обработки списка
Получение последнего элемента X в списке L.
- с использованием встроенных предикатов
`getlast(L, X)` 
- без использования встроенных предикатов
`mgetlast(L, X)`

Примеры использования:
```prolog
?- getlast([1, 2, 4], X).
X = 4 ;
false.
      
?- mgetlast([1, 2, 4], X).
X = 4 ;
false.
```

Реализация:
- с использованием встроенных предикатов. Создается на основе встроенного предиката `append`, который конкатенирует какой-то список `_` и список, состоящий из последнего эл-та `[X]` в список `L`
```prolog
getlast(L, X) :- append(_,[X],L).
```
- без использования встроенных предикатов. Задается рекурсивно. Последний эл-т одноэлементного списка - сам эл-т. Если в списке > 1 эл-та, то отделяем хвост `L` и рассматриваем его как одноэлементный список.
```prolog
mgetlast([X], X).
mgetlast([_|L], X) :- mgetlast(L, X).
```

## Задание 1.2: Предикат обработки числового списка

Суммирование всех элементов списка.

Реализация, формат ввода (список, сумма элементов)
```prolog
msum([], 0).
msum([X|T], N) :- msum(T, N1), N is N1 + X.
```
Задаётся рекурсивно. Сумма элементов пустого списка равна нулю. Если в списке больше нуля элементов, то отделяем начало `X` от хвоста `T` и прибавляем к сумматору `N1`. Получаем сумму `N`. 

Примеры использования:
```prolog
?- msum([1, -9, 4, 3], X).
X = -1.

?- msum([1, 0, 0,0, 0, 0], X).
X = 1.
```
## Задание 1.3: Пример совместного использования предикатов

Предикат для нахождение длины списка до и после удаления последнего элемента и вывод последнего элемента
```prolog
coop(L, X1, P, X2) % Формат ввода: (список, длина до удаления, последний эл-т, длина после удаления)
```

Примеры использования:
```prolog
?- coop([1,2,4],X1,P,X2).
X1 = 3, % длина до удаления
P = 4, % последний эл-т
X2 = 2 ; % длина после удаления
```

Реализация:
```prolog
coop(L, X1, P, X2):-
    mlength(L,X1),
    mgetlast(L, P),
    mremove(P, L, L1),
    mlength(L1, X2).
```




## Выводы

Приступая к изучению какой-то предметной области, важно в самом начале показать основные принципы работы с этой предметной областью. В нашем случае для Логического программирования этим показательным примером стали списки.  Выполняя данную лабораторную работу, я закрепил в своей голове такие основные принципы:
- пытаться думать о задаче, как о ряде вложенных более простых задач,
- рекурсия довольно хорошо справляется с решением ряда задач, особенно математического характера,
- нужно быть поаккуратней с именованем термов.

Надеюсь дальнейшие лабораторные работы пополнят запас этих принципов и расширят мои знания в Логическом программировании. 
